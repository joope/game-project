<html>
  <head>
    <title>A Multiplayer Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      canvas {
        /*box-sizing: border-box;
        width: 100%;
        height: 100vh;
        border: 5px solid black;*/
      }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/static/vector2d.js"></script>
  </head>
  <body>
    <canvas id="game"></canvas>
  </body>
  <script>
    var socket = io();

    var canvas = document.getElementById("game");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    var ctx=canvas.getContext("2d");

    var players = {}

    var ball = {
      pos: new Vec2(300, 300),
      z: 0.0,
      vel: new Vec2(0, 0),
      vz: 0.0,
      az: 0.0
    }

    var score = {
      red: 0,
      blu: 0
    }

    var arena = {
      left: 0,
      right: canvas.width,
      top: 0,
      bottom: canvas.height
    }

    arena["width"] = arena.right - arena.left;
    arena["height"] = arena.bottom - arena.top;

    function Goal(args) {
      this.pos = args.pos;
      this.width = args.width;
      this.height = args.height;
      this.fillStyle = args.fillStyle;
    }

    Goal.prototype.draw = function() {
      let pos = worldToScreen(this.pos);
      ctx.fillStyle = this.fillStyle;
      ctx.fillRect(pos.x, pos.y, this.width, this.height);
    }

    let goalHeight = arena.height * 0.25;
    let goalWidth = 16;

    var goals = [
      /* Red Goal */
      new Goal({
        pos: new Vec2(arena.right - goalWidth, arena.height * 0.5 - goalHeight/2),
        width: goalWidth,
        height: goalHeight,
        fillStyle: "red",
        strokeStyle: "red",
        lineWidth: "3"
      }),
      /* Blue Goal */
      new Goal({
        pos: new Vec2(0, arena.height * 0.5 - goalHeight/2),
        width: 16,
        height: goalHeight,
        fillStyle: "blue",
        strokeStyle: "blue",
        lineWidth: "3"
      })
    ]

    const friction = 0.98;
    const turnRate = 0.2;
    const maxV = 0.9;
    const physicsTicksPerFrame = 2;
    const simulationSpeed = 1.0;

    const playerSize = 20;
    const ballSize = 30;
    const borderPadding = 20;

    let cameraPos = new Vec2(0, 0);

    function worldToScreen(pWorld) {
      let pScreen = Vec2.add(Vec2.multiply(cameraPos, -1), pWorld);
      return pScreen;
    }

    function handleUpdate() {
      t = performance.now();

      for (let i=0;i<physicsTicksPerFrame;i++) {
          dt = simulationSpeed / physicsTicksPerFrame;
          updatePlayerPositions(dt);
          updateBallPosition(dt);
      }

      drawArena();
      drawGoals();
      drawPlayers();
      drawBall();
      drawPerf(performance.now() - t)
      window.requestAnimationFrame(handleUpdate)
    }

    function drawArena() {
      let pos = worldToScreen(new Vec2(arena.left, arena.top,));
      ctx.clearRect(0,0,canvas.width, canvas.height);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 5;
      ctx.strokeRect(pos.x, pos.y, arena.width, arena.height);
      ctx.lineWidth = 1;
    }

    function drawGoals() {
      for (i = 0; i < goals.length; i++) {
        goals[i].draw();
      }
    }

    function forEachPlayer(callBack) {
      var keys = Object.keys(players);
      for (i = 0; i < keys.length; i++) {
        callBack(players[keys[i]]);
      }
    }

    function updatePlayerPositions(dt) {
      forEachPlayer(function(player){
        player.vel.x = (Math.cos(player.dir) + player.vel.x) * player.v;
        player.vel.y = (Math.sin(player.dir) + player.vel.y) * player.v;
        player.pos = updatePos(player.pos, Vec2.multiply(player.vel, dt));
      });
    }

    function updatePlayerData(control_event) {
      if (!players[control_event.id]) {
        players[control_event.id] = {
          pos: new Vec2(100, 100),
          v: 0,
          vel: new Vec2(0, 0), 
          dir: 0
        }
      }
      var player = players[control_event.id];
      player.v = updateV(player.v, Math.max(0.0, Math.min(1.0, control_event.v)));

      // TODO store target dir but update the smoothed direction later
      player.dir = control_event.d;
    }

    function updateV(v, control_v) {
      if (control_v === 0) return v * 0.99;
      var new_v = control_v;

      if (new_v < -maxV) return -maxV;
      if (new_v > maxV) return maxV;

      return new_v;
    }

    function updatePos(pos, vel) {
      newpos = Vec2.add(pos, vel);
      newpos.x = Math.max(borderPadding, newpos.x);
      newpos.y = Math.max(borderPadding, newpos.y);
      newpos.x = Math.min(arena.width - borderPadding, newpos.x);
      newpos.y = Math.min(arena.height - borderPadding, newpos.y);
      return newpos;
    }

    function drawPlayers() {
      forEachPlayer(function(player){
        let pos = worldToScreen(player.pos);

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, playerSize, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(pos.x + Math.cos(player.dir) * playerSize, pos.y + Math.sin(player.dir) * playerSize);
        ctx.stroke();
        ctx.closePath();
      });
    }

    function updateBallPosition(dt) {
      forEachPlayer(function(player){
        var delta = Vec2.subtract(ball.pos, player.pos);

        var distance = delta.magnitude();
        if (distance <= 50 && ball.z < 2) {
          var direction = Math.atan2(delta.x, delta.y);
          ball.vel.x = (Math.sin(direction) + 0.5*player.vel.x) * player.v * 4;
          ball.vel.y = (Math.cos(direction) + 0.5*player.vel.y) * player.v * 4;
          ball.vz = 5 * player.v + 2;
          player.pos = Vec2.subtract(player.pos, Vec2.multiply(delta, 0.1));
          player.v = player.v * 0.2;
        }
      })
      ball.vel = Vec2.multiply(ball.vel, 0.99);
      ball.vz = Math.max(ball.vz - 0.1, -5);
      ball.pos = updatePos(ball.pos, ball.vel);
      ball.z = Math.max(ball.z + dt * ball.vz, 0);
      if (ball.pos.x === arena.width - borderPadding || ball.pos.x === borderPadding) ball.vel.x = -ball.vel.x;
      if (ball.pos.y === arena.height - borderPadding || ball.pos.y === borderPadding) ball.vel.y = -ball.vel.y;
      if (ball.z <= 0) ball.vz = -ball.vz * 0.6;
    }

    function drawBall() {
      let pos = worldToScreen(ball.pos);
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, ballSize + ball.z, 0, 2 * Math.PI);
      ctx.fillStyle = "#c2c2c2";
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }

    function drawPerf(time) {
      ctx.font = "12px";
      ctx.fillText(time.toFixed(2) + 'ms', 2, 10);
    }

    socket.on('control_event', updatePlayerData);

    window.requestAnimationFrame(handleUpdate);
  </script>
</html>
