<html>
  <head>
    <title>A Multiplayer Game</title>
    <style>
      #flashmessage {
        font-family: sans-serif;
        font-size: 128px;
        margin: 0;
        position: absolute;
        top: 25%;
        left: 50%;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        transform: translate(-50%, -50%)
      }
      @keyframes fadein {
        from
            {
              transform: scaleX(0);
            }
        to
          {
              transform: scaleX(1);
          }
      }
      #startbutton {
        font-size: 500%;
        font-family: sans-seritf;
        background: green;
        text-align: center;
        margin: 0;
        margin-left: auto;
        margin-right: auto;
        position: absolute;
        top: 75%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0.8;
      }
      body {
        margin: 0;
        padding: 0;
      }
      canvas {
        /*box-sizing: border-box;
        width: 100%;
        height: 100vh;
        border: 5px solid black;*/
      }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/vector2d.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.0.9/howler.core.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
    <span id="flashmessage"></span>
    <button id="startbutton" onclick="startGame(true)">Start Game</button>
    <canvas id="game"></canvas>
    </div>
  </body>
  <script>
    var socket = io();
    var ID = '';
    socket.emit('registerServer', function(serverId){
      ID = serverId;
    });

    var canvas = document.getElementById("game");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.onresize = function(event) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    var ctx=canvas.getContext("2d");

    var flashTimer = null;

    var music = new Howl({
      src: ['/motiv_music_1.wav'],
      volume: 0.5,
    });

    var whistle = new Howl({
      src: ['/whistle.wav'],
      volume: 0.5,
    });

    // Game settings -->
    let isGoal = false;

    const friction = 0.98;
    const turnRate = 0.2;
    const maxV = 0.9;
    const physicsTicksPerFrame = 4;
    const simulationSpeed = 1.0;

    const playerSize = 40;
    const ballSize = 50;
    const borderPadding = 20;

    let cameraPos = new Vec2(0, 0);

    const STATE_INVALID = "invalid";
    const STATE_INIT = "init";
    const STATE_WARMUP = "warmup";
    const STATE_TEAM_SELECT = "teamselect";
    const STATE_GAME = "game";
    const STATE_GOAL = "goal";
    const STATE_FACE_OFF = "face_off";
    const STATE_PARTY = "party";

    let arenaGap = 75;

    let oldGameState = STATE_INVALID;
    let gameState = STATE_INVALID;

    let Message = "Init";

    var score = {
      red: 0,
      blue: 0
    }
    // Settings end

    // Game object initializations -->
    var players = {}
    var ball = {
      pos: new Vec2(300, 300),
      z: 0.0,
      vel: new Vec2(0, 0),
      vz: 0.0,
      az: 0.0
    }
    var arena = {
      left: arenaGap,
      right: canvas.width - arenaGap,
      top: 0,
      bottom: canvas.height
    }

    arena.width = arena.right - arena.left;
    arena.height = arena.bottom - arena.top;
    arena.center = new Vec2(arena.left + arena.width/2, arena.top + arena.height/2);

    const goalHeight = arena.height * 0.2;
    const goalWidth = arenaGap;

    let left_pad = arena.left + ballSize;
    let right_pad = arena.right - ballSize;
    let top_pad = arena.top + ballSize;
    let bottom_pad = arena.bottom - ballSize;

    function Goal(args) {
      this.pos = args.pos;
      this.width = args.width;
      this.height = args.height;
      this.fillStyle = args.fillStyle;
    }

    Goal.prototype.draw = function() {
      let pos = worldToScreen(this.pos);
      ctx.fillStyle = this.fillStyle;
      ctx.strokeStyle = this.strokeStyle;
      ctx.fillRect(pos.x, pos.y, this.width, this.height);
      ctx.stroke();
    }

    var goals = [
      /* Red Goal */
      /* Blue Goal */
      new Goal({
        pos: new Vec2(arena.left - goalWidth, arena.height * 0.5 - goalHeight/2),
        width: goalWidth,
        height: goalHeight,
        fillStyle: "rgba(0, 30, 200, 0.8)",
        strokeStyle: "blue",
        lineWidth: "3"
      }),
      new Goal({
        pos: new Vec2(arena.right, arena.height * 0.5 - goalHeight/2),
        width: goalWidth,
        height: goalHeight,
        fillStyle: "rgba(200, 30, 0, 0.8)",
        strokeStyle: "red",
        lineWidth: "3"
      })
    ]

    var canStart = false;
    var timer = 30;
    var startButton = document.getElementById('startbutton');

    // Game object initializations end

    function startGame(bool) {
      canStart = bool;
      startButton.style.visibility = "hidden";
    }

    function setTimer() {
      startButton.innerHTML = "Start Game (" + timer + ")";
      timer -= 1;
      if (timer >= 0) {
        window.setTimeout(setTimer, 1000);
      } else {
        startButton.style.visibility = "hidden";
        canStart = true;
        timer = 30;
      }
    }

    let stateLogic = function*() {
      while (true) {
        console.log("Started a new game");
        yield STATE_INIT;

        var timeout = function*(state, interval) {
          var start = getTime();
          while (getTime() - start < interval) {
            yield state;
          }
        }

        while (!canStart) {
          yield STATE_WARMUP;
        }
        yield* timeout(STATE_TEAM_SELECT, 10000);
        while (score.red < 3 && score.blue < 3) {
          yield STATE_GAME;

          if (isGoal) {
            yield* timeout(STATE_GOAL, 6000);
            console.log("Face off");
            yield* timeout(STATE_FACE_OFF, 1000);
          }
        }

        console.log("Game ended", score);
        end = getTime();

        timeout(STATE_PARTY, 5000);
      }
    }

    // We need to instantiate our generator before we can use it.
    let stateMachine = stateLogic();

    function handleGameTick() {
      t = performance.now();

      oldGameState = gameState;
      gameState = stateMachine.next().value;

      // Actions to do when entering a state

      if (oldGameState != gameState) {
        if (gameState == STATE_INIT) {
          console.log("Initializing game");
          startButton.style.visibility = "visible";
          initGamePositions();
          score.red = 0;
          score.blue = 0;
        } else if (gameState == STATE_WARMUP) {
            updateMessage("WARMUP", "BLACK", 30000);
            setTimer();
        } else if (gameState == STATE_TEAM_SELECT) {
            updateMessage("CHOOSE YOUR TEAM", "RED", 10000);
        } else if (gameState == STATE_GAME) {
            updateMessage("PLAY", "GREEN", 3000);
            initGamePositions();
            whistle.play();
        } else if (gameState == STATE_GOAL) {
            console.log("Goal!");
            music.play();
            socket.emit("triggersound", {sound:"vuvuzela"});
        } else if (gameState == STATE_FACE_OFF) {
          initGamePositions();
          isGoal = false;
        }

        // Actions on specific state transitions

        if (oldGameState == STATE_FACE_OFF && gameState == STATE_GAME) {
            music.stop();
            canStart = false;
        }
      }

      for (let i=0;i<physicsTicksPerFrame;i++) {
          dt = simulationSpeed / physicsTicksPerFrame;

          // Player's can't move during the face off
          if (gameState != STATE_FACE_OFF) {
            updatePlayerPositions(dt);
          }

          // Ball stays still after a goal (maybe not a good idea?)
          updateBallPosition(dt);
      }

      if (gameState === 'teamselect') {
        updatePlayerTeams(players);
      }

      drawArena();
      drawScoreboard();
      drawPlayers();
      drawBall();
      drawGoals();
      drawDebug(performance.now() - t);
      window.requestAnimationFrame(handleGameTick);
    }

    // Object position calculations -->

    function updatePlayerPositions(dt) {
      forEachPlayer(function(player){
        /*
        var dir = new Vec2(Math.cos(player.dir), Math.sin(player.dir));
        var weight = Vec2.dot(dir, player.vel) / player.vel.magnitude();
        if (player.vel.x == 0.0 && player.vel.y == 0.0) {
          // TODO epsilon check
          weight = 0.0;
        }
        weight = Math.max(Math.cos(Math.min(Math.PI, player.vel.magnitude() / 2.0)), weight);
        console.log("weight", weight);
        weight *= 0.1;
        */
        weight = 0.1;

        player.vel.x = player.vel.x + (Math.cos(player.dir) * player.v * weight);
        player.vel.y = player.vel.y + (Math.sin(player.dir) * player.v * weight);

        Vec2.add_inplace(player.pos, Vec2.multiply(player.vel, dt), player.pos);
        const newpos = player.pos.clone();
        newpos.x = Math.max(arena.left + playerSize, newpos.x);
        newpos.y = Math.max(arena.top, newpos.y);
        newpos.x = Math.min(arena.right - playerSize, newpos.x);
        newpos.y = Math.min(arena.bottom, newpos.y);

        // If position changed above we know we hit a border.
        if (newpos.x != player.pos.x) {
          player.vel.x *= -1.0;
        }
        if (newpos.y != player.pos.y) {
          player.vel.y *= -1.0;
        }

        //TODO mirror also direction

        newpos.copyTo(player.pos); // Actually update player position

        Vec2.multiply_inplace(player.vel, 0.99, player.vel);
      });

      var keys = Object.keys(players);
      var diff = new Vec2(0, 0); // TODO make these global?
      var n1 = new Vec2(0, 0);
      var n2 = new Vec2(0, 0);
      var temp = new Vec2(0, 0);

      // TODO handle each pair only once?
      for (i = 0; i < keys.length; i++) {
      for (j = i; j < keys.length; j++) {
        if (i == j) continue;
        var pl1 = players[keys[i]];
        var pl2 = players[keys[j]];

        Vec2.subtract_inplace(pl1.pos, pl2.pos, diff);
        var dist = diff.magnitude();
        var threshold = playerSize*2-5;
        if (dist > threshold) {
          continue;
        }

        // normalize diff vector
        Vec2.multiply_inplace(diff, 1.0/dist, diff);

        // Move both players outwards
        Vec2.multiply_inplace(diff, 0.5*(threshold - dist)+5, temp);
        Vec2.add_inplace(pl1.pos, temp, pl1.pos);
        Vec2.subtract_inplace(pl2.pos, temp, pl2.pos);

        // https://www.gamasutra.com/view/feature/131424/pool_hall_lessons_fast_accurate_.php?page=3


        var a1 = Vec2.dot(pl1.vel, diff);
        var a2 = Vec2.dot(pl2.vel, diff);

        // Using the optimized version,
        // optimizedP =  2(a1 - a2)
        //              -----------
        //                m1 + m2
        const mass1 = 1.0;
        const mass2 = 1.0;
        var optimizedP = (2.0 * (a1 - a2)) / (mass1 + mass2);

         // Calculate v1', the new movement vector of circle1
        // v1' = v1 - optimizedP * m2 * n
        // Vector v1b = v1 - optimizedP * circle2.mass * n;
        diff.copyTo(n1);
        Vec2.multiply_inplace(n1, mass2, n1);
        Vec2.multiply_inplace(n1, optimizedP, n1);
        Vec2.subtract_inplace(pl1.vel, n1, pl1.vel);

        // Calculate v1', the new movement vector of circle1
        // v2' = v2 + optimizedP * m1 * n
        // Vector v2' = v2 + optimizedP * circle1.mass * n;
        diff.copyTo(n2);
        Vec2.multiply_inplace(n2, mass1, n2);
        Vec2.multiply_inplace(n2, optimizedP, n2);
        //console.log("aluks", pl2.vel, players[keys[j]].vel);
        Vec2.add_inplace(pl2.vel, n1, pl2.vel);
        //console.log("lopuks", pl2.vel, players[keys[j]].vel);

        //pl1.vel.x = 100;
        //pl2.vel.x = 100;

        //player.vel.x = (Math.cos(player.dir) + player.vel.x) * player.v;
        //player.vel.y = (Math.sin(player.dir) + player.vel.y) * player.v;
        //player.pos = updatePos(player.pos, Vec2.multiply(player.vel, dt));
        //callBack(players[keys[i]], i, keys[i]);
      }
      }
    }

    function updatePlayerTeams() {
      forEachPlayer(function(player){
        if (player.pos.x < arena.center.x) {
          player.team = 0;
        } else {
          player.team = 1;
        }
      })
    }

    function updateBallPosition(dt) {
      forEachPlayer(function(player, i, playerID){
        var delta = Vec2.subtract(ball.pos, player.pos);
        var normal = new Vec2(delta.x, delta.y); // TODO inplace?
        normal.normalize();
        var distance = delta.magnitude();
        var threshold = playerSize + ballSize;

        if ((distance <= threshold) && ball.z < 2) {
          var direction = Math.atan2(delta.x, delta.y);
          ball.vel.x = (Math.sin(direction) + 1.0 * player.vel.x);
          ball.vel.y = (Math.cos(direction) + 1.0 * player.vel.y);
          ball.vz = ball.vz + 0.2*player.vel.magnitude();
          Vec2.subtract_inplace(player.pos, Vec2.multiply(normal, threshold - distance), player.pos);
          Vec2.multiply_inplace(player.vel, -0.2, player.vel);
          socket.emit('crash', playerID);
        }
      })
      ball.vel = Vec2.multiply(ball.vel, 0.99);
      ball.vz = Math.max(ball.vz - 0.05, -5);
      ball.pos = Vec2.add(ball.pos, ball.vel);
      ball.z = Math.max(ball.z + dt * ball.vz, 0);

      if (ball.z <= 0) ball.vz = -ball.vz * 0.6;

      // We allow goals only during STATE_GAME if no goals have been made
      if (gameState == STATE_GAME && !isGoal) {
        if (ballInBlueGoal()) {
          score.red = score.red + 1;
          isGoal = true;
          updateMessage("RED SCORES", "red", 6000);
        }
        if (ballInRedGoal()){
          score.blue = score.blue + 1;
          isGoal = true;
          updateMessage("BLUE SCORES", "blue", 6000);
        }
      }
      // TODO bounce ball inside the goal
      if (!ballInCenterArea() && ball.pos.x < left_pad || !ballInCenterArea() && ball.pos.x > right_pad) {
        ball.vel.x = -ball.vel.x;
      }
      if (!isGoal && !ballInCenterArea()) {
        ball.pos.x = Math.max(left_pad, ball.pos.x);
        ball.pos.x = Math.min(right_pad, ball.pos.x);
      }
      if (ball.pos.y < top_pad || ball.pos.y > bottom_pad) ball.vel.y = -ball.vel.y;
      ball.pos.y = Math.max(top_pad, ball.pos.y);
      ball.pos.y = Math.min(bottom_pad, ball.pos.y);
    }

    // Object position calculations end

    // Draw functions start

    function drawArena() {
      let pos = worldToScreen(new Vec2(arena.left, arena.top));

      // Background
      ctx.fillStyle = 'rgb(100, 100, 100)';
      ctx.fillRect(0,0,canvas.width, canvas.height);

      // Foreground
      ctx.fillStyle = 'white';
      ctx.fillRect(pos.x, pos.y, arena.width, arena.height);
      ctx.lineWidth = 2;

      // Center line
      ctx.beginPath();
      ctx.strokeStyle = 'lightgrey';
      ctx.moveTo(arena.center.x, 0);
      ctx.lineTo(arena.center.x, arena.bottom);
      ctx.closePath();
      ctx.stroke();

      // Center circle
      ctx.beginPath();
      ctx.arc(arena.center.x, arena.center.y, 100, 0, 2 * Math.PI);
      ctx.closePath();
      ctx.stroke();
    }

    function drawPlayers() {
      forEachPlayer(function(player){
        let pos = worldToScreen(player.pos);

        ctx.beginPath();
        ctx.fillStyle = ['lightblue', 'lightpink'][player.team];
        ctx.fillStyle = ['lightblue', 'lightpink'][player.team];
        ctx.arc(pos.x, pos.y, playerSize, 0, 2 * Math.PI);
        ctx.fill();
        // ctx.moveTo(pos.x, pos.y);
        // ctx.lineTo(pos.x + Math.cos(player.dir) * playerSize, pos.y + Math.sin(player.dir) * playerSize);
        // ctx.stroke();
        ctx.font = "24px Arial"
        ctx.fillText(player.name, player.pos.x - ctx.measureText(player.name).width / 2, player.pos.y + playerSize * 2);
        ctx.font = "72px Arial";
        ctx.save();
        ctx.translate(player.pos.x, player.pos.y);
        ctx.rotate(player.dir + Math.PI/2)
        ctx.fillText(player.emoji, -ctx.measureText(player.emoji).width / 2, 32);
        ctx.closePath();
        ctx.restore();
      });
    }

    function drawBall() {
      let pos = worldToScreen(ball.pos);
      ctx.beginPath();
      ctx.strokeStyle = 'black';
      ctx.arc(pos.x, pos.y, ballSize + ball.z * 3, 0, 2 * Math.PI);
      ctx.fillStyle = "#c2c2c2";
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }

    function drawGoals() {
      if (gameState != STATE_WARMUP) {
        for (i = 0; i < goals.length; i++) {
          goals[i].draw();
          }
      }
    }

    function drawDebug(time) {
      ctx.font = "12px serif";
      ctx.fillStyle = 'rgb(255,255,255)';
      ctx.fillText(time.toFixed(2) + 'ms', 2, 10);
      ctx.fillText("State: " + gameState, 2, 30);
      ctx.fillText("ID: " + ID, 2, 50);
    }

    function drawScoreboard() {
      ctx.font = "96px sans-serif";
      ctx.fillStyle = 'lightgrey';
      let pos = new Vec2(arena.center.x - 100, arena.top + 100);
      worldPos = worldToScreen(pos);
      ctx.fillText(score.blue + " - " + score.red, worldPos.x, worldPos.y);
    }

    function updateMessage(text, style, timeout) {
      /* var flashmessage = document.getElementById('flashmessage');
      var newmsg = flashmessage.parentNode.replaceChild(flashmessage.cloneNode(true), flashmessage);
      */
      var newmsg = document.getElementById('flashmessage');
      newmsg.innerHTML = text;
      newmsg.style.color = style;
      // newmsg.style.animation = "fadein 0.5s"
      if (flashTimer != null) {
        clearInterval(flashTimer);
      }
      flashTimer = setInterval(clearMessage, timeout);
    }

    function clearMessage() {
        var message = document.getElementById('flashmessage');
        message.innerHTML = "";
        flashmessage.style.color = "black";
        // flashmessage.style.animation = "";
        clearInterval(flashTimer);
        flashTimer = null;
    }

    // Helper functions -->
    function getRandomCoordinates(){
      return new Vec2(
        Math.floor(Math.random() * Math.floor(arena.width)), 
        Math.floor(Math.random() * Math.floor(arena.height))
      );
    };

    function forEachPlayer(callBack) {
      var keys = Object.keys(players);
      for (i = 0; i < keys.length; i++) {
        callBack(players[keys[i]], i, keys[i]);
      }
    }

    function registerPlayer(data) {
      console.log(data);
      if (!players[data.playerID]){
        players[data.playerID] = {
          pos: getRandomCoordinates(),
          v: 0,
          vel: new Vec2(0, 0),
          dir: 0,
          team: 0,
          name: data.name,
          emoji: data.emoji
        }
      } else {
        players[data.playerID].name = data.name;
      }
    }

    function updatePlayerData(control_event) {
      if (!players[control_event.id]) {
        return;
      }
      var player = players[control_event.id];
      player.v = updateV(player.v, Math.max(0.0, Math.min(1.0, control_event.v)));

      // TODO store target dir but update the smoothed direction later
      player.dir = control_event.d;
    }

    function updateV(v, control_v) {
      if (control_v === 0) return v * 0.99;
      var new_v = control_v;

      if (new_v < -maxV) return -maxV;
      if (new_v > maxV) return maxV;

      return new_v;
    }

    function worldToScreen(pWorld) {
      let pScreen = Vec2.add(Vec2.multiply(cameraPos, -1), pWorld);
      return pScreen;
    }

    function initGamePositions(){
      ball.pos = arena.center.clone();
      ball.vel = new Vec2(0,0);
      ball.z = 10.0;
      ball.az = 0.0;
      ball.vz = 0.0;

      forEachPlayer(function(player, i){
        var y = arena.center.y - 50*(i - player.team) + (Object.keys(players).length / 2) * 50 - 50;
        player.pos = player.team === 0 
          ? new Vec2(arena.center.x * 0.3, y)
          : new Vec2(arena.center.x * 1.7, y)
        player.v = 0;
        player.dir = player.team === 0 ? 0 : Math.PI;
      });
    }

    function getTime() {
      return performance.now();
    }

    function ballInCenterArea() {
      return ball.pos.y >= goals[0].pos.y && ball.pos.y <= goals[0].pos.y + goals[0].height;
    }

    function ballInBlueGoal() {
      return (isGoal && ball.pos.x <= arena.left) || ball.pos.y >= goals[0].pos.y && ball.pos.y <= goals[0].pos.y + goals[0].height && ball.pos.x <= arena.left;
    }

    function ballInRedGoal() {
      return (isGoal && ball.pos.x >= arena.right) || ball.pos.y >= goals[1].pos.y && ball.pos.y <= goals[1].pos.y + goals[1].height && ball.pos.x >= arena.right
    }

    // Helper functions end

    socket.on('register', registerPlayer)
    socket.on('control_event', updatePlayerData);
    socket.on('player_disconnect', function(playerID){
      console.log(playerID + ' quit the game')
      // Remove comment to delete players:
      delete players[playerID];
    })

    window.requestAnimationFrame(handleGameTick);
  </script>
</html>
