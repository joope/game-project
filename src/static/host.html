<html>
  <head>
    <title>A Multiplayer Game</title>
    <style>
      #flashmessage {
        font-family: sans-serif;
        font-size: 128px;
        margin: 0;
        position: absolute;
        top: 25%;
        left: 50%;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        transform: translate(-50%, -50%)
      }
      @keyframes fadein {
        from
            {
              transform: scaleX(0);
            }
        to
          {
              transform: scaleX(1);
          }
      }
      #startbutton {
        font-size: 500%;
        font-family: sans-seritf;
        background: green;
        text-align: center;
        margin: 0;
        margin-left: auto;
        margin-right: auto;
        position: absolute;
        top: 75%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0.8;
      }
      body {
        margin: 0;
        padding: 0;
      }
      canvas {
        /*box-sizing: border-box;
        width: 100%;
        height: 100vh;
        border: 5px solid black;*/
      }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/vector2d.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.0.9/howler.core.min.js"></script>
  </head>
  <body>
    <div id="wrapper">
    <span id="flashmessage"></span>
    <button id="startbutton" onclick="startGame(true)">Start Game</button>
    <canvas id="game"></canvas>
    </div>
  </body>
  <script>
    var socket = io();

    var canvas = document.getElementById("game");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    var ctx=canvas.getContext("2d");

    var flashTimer = null;

    var music = new Howl({
      src: ['/motiv_music_1.wav'],
      volume: 0.5,
    });

    // Game settings -->
    let isGoal = false;

    const friction = 0.98;
    const turnRate = 0.2;
    const maxV = 0.9;
    const physicsTicksPerFrame = 4;
    const simulationSpeed = 1.0;

    const playerSize = 20;
    const ballSize = 30;
    const borderPadding = 20;

    let cameraPos = new Vec2(0, 0);

    const STATE_INVALID = "invalid";
    const STATE_INIT = "init";
    const STATE_WARMUP = "warmup";
    const STATE_GAME = "game";
    const STATE_GOAL = "goal";
    const STATE_GOAL_CONTINUE = "goal_continue";
    const STATE_FACE_OFF = "face_off";
    const STATE_PARTY = "party";

    let arenaGap = 75;

    let gameState = STATE_INVALID;

    let Message = "Init";

    var score = {
      red: 0,
      blue: 0
    }
    // Settings end

    // Game object initializations -->
    var players = {}
    var ball = {
      pos: new Vec2(300, 300),
      z: 0.0,
      vel: new Vec2(0, 0),
      vz: 0.0,
      az: 0.0
    }
    var arena = {
      left: arenaGap,
      right: canvas.width - arenaGap,
      top: 0,
      bottom: canvas.height
    }

    arena.width = arena.right - arena.left;
    arena.height = arena.bottom - arena.top;
    arena.center = new Vec2(arena.left + arena.width/2, arena.top + arena.height/2);

    const goalHeight = arena.height * 0.2;
    const goalWidth = arenaGap;

    let left_pad = arena.left + ballSize;
    let right_pad = arena.right - ballSize;
    let top_pad = arena.top + ballSize;
    let bottom_pad = arena.bottom - ballSize;

    function Goal(args) {
      this.pos = args.pos;
      this.width = args.width;
      this.height = args.height;
      this.fillStyle = args.fillStyle;
    }

    Goal.prototype.draw = function() {
      let pos = worldToScreen(this.pos);
      ctx.fillStyle = this.fillStyle;
      ctx.strokeStyle = this.strokeStyle;
      ctx.fillRect(pos.x, pos.y, this.width, this.height);
      ctx.stroke();
    }

    var goals = [
      /* Red Goal */
      /* Blue Goal */
      new Goal({
        pos: new Vec2(arena.left - goalWidth, arena.height * 0.5 - goalHeight/2),
        width: goalWidth,
        height: goalHeight,
        fillStyle: "rgba(0, 30, 200, 0.8)",
        strokeStyle: "blue",
        lineWidth: "3"
      }),
      new Goal({
        pos: new Vec2(arena.right, arena.height * 0.5 - goalHeight/2),
        width: goalWidth,
        height: goalHeight,
        fillStyle: "rgba(200, 30, 0, 0.8)",
        strokeStyle: "red",
        lineWidth: "3"
      })
    ]

    var canStart = false;
    var startButton;

    // Game object initializations end

    function startGame(bool) {
      canStart = bool;
      startButton = document.getElementById('startbutton');
      startButton.style.visibility = "hidden";
    }

    let stateLogic = function*() {
      while (true) {
        console.log("Started a new game");
        start = getTime();
        yield STATE_INIT;

        updateMessage("WARMUP", "BLACK", 30000);
        while (!canStart) {
          yield STATE_WARMUP;
        }
        initGamePositions();
        updateMessage("PLAY", "GREEN", 3000);
        while (score.red < 3 && score.blue < 3) {
          yield STATE_GAME;

          if (isGoal) {
            console.log("Goal!");
            goalTime = getTime();
            music.play();
            socket.emit("triggersound", {sound:"vuvuzela"});
            while (getTime() - goalTime < 6000) {
              yield STATE_GOAL;
            }
            yield STATE_GOAL_CONTINUE; // one frame for player position setup etc.
            console.log("Face off");
            while (getTime() - goalTime < 1000) {
              yield STATE_FACE_OFF;
            }
            music.stop();
          }
        }

        console.log("Game ended", score);
        end = getTime();

        while (getTime() - end < 5000) {
          yield STATE_PARTY;
        }
      }
    }

    // We need to instantiate our generator before we can use it.
    let stateMachine = stateLogic();

    function handleGameTick() {
      t = performance.now();

      gameState = stateMachine.next().value;

      if (gameState == STATE_INIT) {
        console.log("Initializing game");
        initGamePositions();
        score.red = 0;
        score.blue = 0;
      } else if (gameState == STATE_GOAL_CONTINUE) {
        initGamePositions();
        isGoal = false;
      }

      for (let i=0;i<physicsTicksPerFrame;i++) {
          dt = simulationSpeed / physicsTicksPerFrame;

          // Player's can't move during the face off
          if (gameState != STATE_FACE_OFF) {
            updatePlayerPositions(dt);
          }

          // Ball stays still after a goal (maybe not a good idea?)
          updateBallPosition(dt);
      }

      drawArena();
      drawScoreboard();
      drawPlayers();
      drawBall();
      drawGoals();
      drawDebug(performance.now() - t)
      window.requestAnimationFrame(handleGameTick)
    }

    // Object position calculations -->

    function updatePlayerPositions(dt) {
      forEachPlayer(function(player){
        player.vel.x = (Math.cos(player.dir) + player.vel.x) * player.v;
        player.vel.y = (Math.sin(player.dir) + player.vel.y) * player.v;
        player.pos = updatePos(player.pos, Vec2.multiply(player.vel, dt));
      });
    }

    function updateBallPosition(dt) {
      forEachPlayer(function(player){
        var delta = Vec2.subtract(ball.pos, player.pos);

        var distance = delta.magnitude();
        if (distance <= 50 && ball.z < 2) {
          var direction = Math.atan2(delta.x, delta.y);
          ball.vel.x = (Math.sin(direction) + 0.5*player.vel.x) * player.v * 2;
          ball.vel.y = (Math.cos(direction) + 0.5*player.vel.y) * player.v * 2;
          ball.vz = ball.vz + player.v;
          player.pos = Vec2.subtract(player.pos, Vec2.multiply(delta, 0.1));
          player.v = player.v * 0.2;
        }
      })
      ball.vel = Vec2.multiply(ball.vel, 0.99);
      ball.vz = Math.max(ball.vz - 0.05, -5);
      ball.pos = Vec2.add(ball.pos, ball.vel);
      ball.z = Math.max(ball.z + dt * ball.vz, 0);

      if (ball.z <= 0) ball.vz = -ball.vz * 0.6;

      // We allow goals only during STATE_GAME if no goals have been made
      if (gameState == STATE_GAME && !isGoal) {
        if (ballInBlueGoal()) {
          score.red = score.red + 1;
          isGoal = true;
          updateMessage("RED SCORES", "red", 6000);
        }
        if (ballInRedGoal()){
          score.blue = score.blue + 1;
          isGoal = true;
          updateMessage("BLUE SCORES", "blue", 6000);
        }
      }
      // TODO bounce ball inside the goal
      if (!ballInCenterArea() && ball.pos.x < left_pad || !ballInCenterArea() && ball.pos.x > right_pad) {
        ball.vel.x = -ball.vel.x;
      }
      if (!isGoal && !ballInCenterArea()) {
        ball.pos.x = Math.max(left_pad, ball.pos.x);
        ball.pos.x = Math.min(right_pad, ball.pos.x);
      }
      if (ball.pos.y < top_pad || ball.pos.y > bottom_pad) ball.vel.y = -ball.vel.y;
      ball.pos.y = Math.max(top_pad, ball.pos.y);
      ball.pos.y = Math.min(bottom_pad, ball.pos.y);
    }

    // Object position calculations end

    // Draw functions start

    function drawArena() {
      let pos = worldToScreen(new Vec2(arena.left, arena.top));
      ctx.fillStyle = 'rgb(70, 70, 70)'
      ctx.fillRect(0,0,canvas.width, canvas.height);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.fillStyle = 'rgb(255, 255, 255)'
      ctx.fillRect(pos.x, pos.y, arena.width, arena.height);
      ctx.lineWidth = 1;
    }

    function drawPlayers() {
      forEachPlayer(function(player){
        let pos = worldToScreen(player.pos);

        ctx.beginPath();
        ctx.strokeStyle = ['blue', 'red'][player.team];
        ctx.fillStyle = ['blue', 'red'][player.team];
        ctx.arc(pos.x, pos.y, playerSize, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(pos.x + Math.cos(player.dir) * playerSize, pos.y + Math.sin(player.dir) * playerSize);
        ctx.stroke();
        ctx.closePath();
      });
    }

    function drawBall() {
      let pos = worldToScreen(ball.pos);
      ctx.beginPath();
      ctx.strokeStyle = 'black';
      ctx.arc(pos.x, pos.y, ballSize + ball.z * 3, 0, 2 * Math.PI);
      ctx.fillStyle = "#c2c2c2";
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }

    function drawGoals() {
      if (gameState != STATE_WARMUP) {
        for (i = 0; i < goals.length; i++) {
          goals[i].draw();
          }
      }
    }

    function drawDebug(time) {
      ctx.font = "12px serif";
      ctx.fillStyle = 'rgb(255,255,255)';
      ctx.fillText(time.toFixed(2) + 'ms', 2, 10);
      ctx.fillText("State: " + gameState, 2, 30);
    }

    function drawScoreboard() {
      ctx.font = "96px sans-serif";
      ctx.fillStyle = 'lightgrey';
      let pos = new Vec2(arena.center.x - 100, arena.top + 100);
      worldPos = worldToScreen(pos);
      ctx.fillText(score.blue + " - " + score.red, worldPos.x, worldPos.y);
    }

    function updateMessage(text, style, timeout) {
      /* var flashmessage = document.getElementById('flashmessage');
      var newmsg = flashmessage.parentNode.replaceChild(flashmessage.cloneNode(true), flashmessage);
      */
      var newmsg = document.getElementById('flashmessage');
      newmsg.innerHTML = text;
      newmsg.style.color = style;
      // newmsg.style.animation = "fadein 0.5s"
      if (flashTimer != null) {
        clearInterval(flashTimer);
      }
      flashTimer = setInterval(clearMessage, timeout);
    }

    function clearMessage() {
        var message = document.getElementById('flashmessage');
        message.innerHTML = "";
        flashmessage.style.color = "black";
        // flashmessage.style.animation = "";
        clearInterval(flashTimer);
        flashTimer = null;
    }

    // Helper functions -->
    function getRandomCoordinates(){
      return new Vec2(
        Math.floor(Math.random() * Math.floor(arena.width)), 
        Math.floor(Math.random() * Math.floor(arena.height))
      );
    };

    function forEachPlayer(callBack) {
      var keys = Object.keys(players);
      for (i = 0; i < keys.length; i++) {
        callBack(players[keys[i]], i);
      }
    }

    function updatePlayerData(control_event) {
      if (!players[control_event.id]) {
        players[control_event.id] = {
          pos: getRandomCoordinates(),
          v: 0,
          vel: new Vec2(0, 0),
          dir: 0,
          team: Object.keys(players).length % 2
        }
      }
      var player = players[control_event.id];
      player.v = updateV(player.v, Math.max(0.0, Math.min(1.0, control_event.v)));

      // TODO store target dir but update the smoothed direction later
      player.dir = control_event.d;
    }

    function updateV(v, control_v) {
      if (control_v === 0) return v * 0.99;
      var new_v = control_v;

      if (new_v < -maxV) return -maxV;
      if (new_v > maxV) return maxV;

      return new_v;
    }

    function updatePos(pos, vel) {
      const newpos = Vec2.add(pos, vel);
      newpos.x = Math.max(arena.left + playerSize, newpos.x);
      newpos.y = Math.max(arena.top, newpos.y);
      newpos.x = Math.min(arena.right - playerSize, newpos.x);
      newpos.y = Math.min(arena.bottom, newpos.y);
      return newpos;
    }

    function worldToScreen(pWorld) {
      let pScreen = Vec2.add(Vec2.multiply(cameraPos, -1), pWorld);
      return pScreen;
    }

    function initGamePositions(){
      ball.pos = arena.center.clone();
      ball.vel = new Vec2(0,0);
      ball.z = 10.0;
      ball.az = 0.0;
      ball.vz = 0.0;

      forEachPlayer(function(player, i){
        var y = arena.center.y - 50*(i - player.team) + (Object.keys(players).length / 2) * 50 - 50;
        player.pos = player.team === 0 
          ? new Vec2(arena.center.x * 0.3, y)
          : new Vec2(arena.center.x * 1.7, y)
        player.v = 0;
        player.dir = player.team === 0 ? 0 : Math.PI;
      });
    }

    function getTime() {
      return performance.now();
    }

    function ballInCenterArea() {
      return ball.pos.y >= goals[0].pos.y && ball.pos.y <= goals[0].pos.y + goals[0].height;
    }

    function ballInBlueGoal() {
      return (isGoal && ball.pos.x <= arena.left) || ball.pos.y >= goals[0].pos.y && ball.pos.y <= goals[0].pos.y + goals[0].height && ball.pos.x <= arena.left;
    }

    function ballInRedGoal() {
      return (isGoal && ball.pos.x >= arena.right) || ball.pos.y >= goals[1].pos.y && ball.pos.y <= goals[1].pos.y + goals[1].height && ball.pos.x >= arena.right
    }

    // Helper functions end

    socket.on('control_event', updatePlayerData);
    socket.on('player_disconnect', function(playerID){
      console.log(playerID + ' quit the game')
      // Remove comment to delete players:
      // delete players[playerID];
    })

    window.requestAnimationFrame(handleGameTick);
  </script>
</html>
