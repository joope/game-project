<html>
  <head>
    <title>A Multiplayer Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      canvas {
        box-sizing: border-box;
        width: 100%;
        height: 100vh;
        border: 5px solid black;
      }
    </style>
    <script src="/socket.io/socket.io.js"></script>
  </head>
  <body>
    <canvas id="game"></canvas>
  </body>
  <script>
    var socket = io();

    var canvas = document.getElementById("game");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    var ctx=canvas.getContext("2d");

    var players = {}

    var ball = {
      x: 300,
      y: 300,
      z: 0.0,
      vx: 0.0,
      vy: 0.0,
      vz: 0.0,
      az: 0.0
    }

    const friction = 0.98;
    const turnRate = 0.2;
    const maxV = 0.9;
    const physicsTicksPerFrame = 2;
    const simulationSpeed = 1.0;

    const playerSize = 20;
    const ballSize = 30;
    const borderPadding = 20;

    function handleUpdate() {
      t = performance.now();

      for (let i=0;i<physicsTicksPerFrame;i++) {
          dt = simulationSpeed / physicsTicksPerFrame;
          updatePlayerPositions(dt);
          updateBallPosition(dt);
      }

      ctx.clearRect(0,0,canvas.width, canvas.height);

      drawPlayers();
      drawBall();
      drawPerf(performance.now() - t)
      window.requestAnimationFrame(handleUpdate)
    }

    function forEachPlayer(callBack) {
      var keys = Object.keys(players);
      for (i = 0; i < keys.length; i++) {
        callBack(players[keys[i]]);
      }
    }

    function updatePlayerPositions(dt) {
      forEachPlayer(function(player){
        player.vx = (Math.cos(player.dir) + player.vx) * player.v;
        player.vy = (Math.sin(player.dir) + player.vy) * player.v;
        player.x = updateX(player.x, dt * player.vx);
        player.y = updateY(player.y, dt * player.vy);
      });;
    }

    function updatePlayerData(control_event) {
      if (!players[control_event.id]) {
        console.log("Player " + control_event.id + " joined.");
        players[control_event.id] = {
          x: 100.0,
          y: 100.0,
          v: 0,
          vx: 0.0,
          vy: 0.0,
          dir: 0
        }
      }
      var player = players[control_event.id];
      player.v = updateV(player.v, Math.max(0.0, Math.min(1.0, control_event.v)));

      // TODO store target dir but update the smoothed direction later
      player.dir = control_event.d;
    }

    function updateV(v, control_v) {
      if (control_v === 0) return v * 0.99;
      var new_v = control_v;

      if (new_v < -maxV) return -maxV;
      if (new_v > maxV) return maxV;

      return new_v;
    }

    function updateX(pos, vel) {
      if (pos + vel < borderPadding) return borderPadding;
      if (pos + vel + borderPadding > canvas.width) return canvas.width - borderPadding;
      return pos + vel;
    }

    function updateY(pos, vel) {
      if (pos + vel < borderPadding) return borderPadding;
      if (pos + vel + borderPadding > canvas.height) return canvas.height - borderPadding;
      return pos + vel;
    }

    function drawPlayers() {
      forEachPlayer(function(player){
	      ctx.beginPath();
	      ctx.arc(player.x, player.y, playerSize, 0, 2 * Math.PI);
	      ctx.stroke();
	      ctx.moveTo(player.x, player.y);
	      ctx.lineTo(player.x + Math.cos(player.dir) * playerSize, player.y + Math.sin(player.dir) * playerSize);
	      ctx.stroke();
	      ctx.closePath();
      });
    }

    function updateBallPosition(dt) {
      forEachPlayer(function(player){
        var dx = ball.x - player.x;
        var dy = ball.y - player.y;
        var distance = Math.sqrt(dx*dx + dy*dy);
        //console.log(direction);
        if (distance <= 50 && ball.z < 2) {
          var direction = Math.atan2(dx, dy);
          ball.vx = (Math.sin(direction) + 0.5*player.vx) * player.v * 4;
          ball.vy = (Math.cos(direction) + 0.5*player.vy) * player.v * 4;
          ball.vz = 5 * player.v + 2;
          player.x = player.x - dx*0.1;
          player.y = player.y - dy*0.1;
          player.v = player.v * 0.2;
          console.log(ball);
        }
      })
      ball.vx = ball.vx * 0.99;
      ball.vy = ball.vy * 0.99;
      ball.vz = Math.max(ball.vz - 0.1, -5);
      ball.x = updateX(ball.x, dt * ball.vx);
      ball.y = updateY(ball.y, dt * ball.vy);
      ball.z = Math.max(ball.z + dt * ball.vz, 0);
      if (ball.x === canvas.width - borderPadding || ball.x === borderPadding) ball.vx = -ball.vx;
      if (ball.y === canvas.height - borderPadding || ball.y === borderPadding) ball.vy = -ball.vy;
      if (ball.z <= 0) ball.vz = -ball.vz * 0.6;
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ballSize + ball.z, 0, 2 * Math.PI);
      ctx.fillStyle = "#c2c2c2";
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }

    function drawPerf(time) {
      ctx.font = "12px";
      ctx.fillText(time.toFixed(2) + 'ms', 2, 10);
    }

    socket.on('control_event', updatePlayerData);

    window.requestAnimationFrame(handleUpdate);
  </script>
</html>
